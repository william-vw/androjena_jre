[S2:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv) 
	(?en xpl:description ?descr)
	strConcat("You " ?descr " because you " ?descr2)
	joinLinked(?deriv ", " ", and " " and " xpl:via xpl:description ?descr3)
	strConcat(?descr2 ?descr3 '.' ?sentence)
->
	(?deriv xpl:sentence ?sentence)
]

# cleanup
[S3:
	(?deriv xpl:sentence ?sentence)
	
	# deal with hasX properties
	replaceAll("ou has" "ou have" ?sentence ?sentence2)
	replaceAll("(,|and) has" "$1" ?sentence2 ?sentence3)
	
	# deal with isX properties
	replaceAll("ou is" "ou are" ?sentence3 ?sentence4)
->
	(?deriv xpl:finalSentence ?sentence4)
]

# functors
[S4:
	(<> xpl:output ?deriv)
	countAllLinked(?deriv xpl:via xpl:sourceFunctorName 1)
	(?deriv xpl:via ?en1) (?en1 xpl:sourceFunctorName ?x) 
	(?en1 xpl:derivation ?deriv1) (?deriv1 xpl:functorDescription ?fdescr)
	strConcat("(which " ?fdescr ")" ?sentence)
->
	(?deriv xpl:functorSentence ?sentence)
]

[S5:
	(<> xpl:output ?deriv)
	(?deriv xpl:via ?en1) (?en1 xpl:sourceFunctorName ?n1)
	regex(?n1 "(greaterThan|ge)")
	(?deriv xpl:via ?en2) (?en2 xpl:sourceFunctorName ?n2)
	regex(?n2 "(lessThan|le)")
	(?en1 xpl:sourceFunctorArgs ?a1) listEntry(?a1 1 ?v1)
	(?en2 xpl:sourceFunctorArgs ?a2) listEntry(?a2 1 ?v2)
	strConcat("(which lies between " ?v1 " and " ?v2 ")" ?sentence)
->
	(?deriv xpl:functorSentence ?sentence)
]

#[S3:
#	(<> xpl:output ?deriv)
#	joinLinked(?deriv ", " ", and " " and " xpl:via xpl:derivation xpl:functorDescription ?fdescr) 
#	strConcat("(which " ?fdescr ")" ?sentence)
#	
	# "and is" -> "and"
#	replaceAll("(,|and) is" "$1" ?sentence ?sentence2)
#->
#	(?deriv xpl:functorSentence ?sentence2)
#]