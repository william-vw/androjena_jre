[S1:
	(<> xpl:output ?out) (?out xpl:sourcePredicate ?p) (?out xpl:sourceObject ?o)
	isUri(?o) (?p xpl:string ?ps) (?o xpl:string ?os)
	strConcat (?ps ' ' ?os ?sentence)
->
	(?out xpl:sentence ?sentence)
]

[S2:
	(<> xpl:output ?out) (?out xpl:sourcePredicate ?p) (?out xpl:sourceObject ?o)
	isDType(?o xsd:string) (?p xpl:string ?ps)
	strConcat (?ps ' ' ?o ?sentence)
->
	(?out xpl:sentence ?sentence)
]

[S2:
	(<> xpl:output ?out) (?out xpl:sourcePredicate ?p) (?out xpl:sourceObject ?o)
	isDType(?o xsd:integer) (?p xpl:string ?ps)
	strConcat (?o ' ' ?ps ?sentence)
->
	(?out xpl:sentence ?sentence)
]

[S3:
	(<> xpl:output ?out) (?out xpl:sourcePredicate ?p) (?out xpl:sourceObject "true"^^xsd:boolean)
	(?p xpl:string ?ps)
->
	(?out xpl:sentence ?ps)
]

[S3:
	(<> xpl:output ?out) (?out xpl:sourcePredicate ?p) (?out xpl:sourceObject "false"^^xsd:boolean)
	(?p xpl:string ?ps)
	strConcat("do not " ?ps ?sentence)
->
	(?out xpl:sentence ?sentence)
]

[S4:
	(<> xpl:output ?out) (?out xpl:sourceFunctorName ?x)
->
	(?out xpl:sentence '')
]

[S5:
	(<> xpl:output ?out)
	(?out xpl:entity ?en) (?out xpl:sentence ?sentence)
	strConcat("You have " ?sentence " because you have " ?sentence2)
	joinLinkedStrings(?en ", " ", and " " and " xpl:via xpl:inOutput xpl:sentence ?sentence3)
	strConcat(?sentence2 ?sentence3 '.' ?sentence4)
	replaceAll("has " '' ?sentence4 ?finalSentence)
->
#	remove(?out xpl:sentence ?sentence)
	(?out xpl:finalSentence ?finalSentence)
]

[S6:
	(?out xpl:sourceTerm ?t) isUri(?t) noValue(?t rdf:type xpl:sourceSubject) (?t rdfs:label ?str)
->
	(?t xpl:string ?str)
]

[S7:
	(?out xpl:sourceTerm ?t) isUri(?t) noValue(?t rdf:type xpl:sourceSubject) noValue(?t rdfs:label ?x) localName(?t ?str)
	splitOnCase(?str ' ' ?str2)
->
	(?t xpl:string ?str2)
]

[S8:
	(?out xpl:sourceSubject ?t) isUri(?t) (?t rdf:type xpl:sourceSubject)
->
	(?t xpl:string "You")
]