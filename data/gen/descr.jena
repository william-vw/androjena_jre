# - URI terms

# URI term with label
[D8:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceTerm ?t) isUri(?t) noValue(?t rdf:type xpl:Subject) (?t rdfs:label ?str)
->
	(?t xpl:string ?str)
]

# URI term without label
[D9:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceTerm ?t) isUri(?t) noValue(?t rdf:type xpl:Subject) noValue(?t rdfs:label ?x) localName(?t ?str)
	splitOnCase(?str ' ' ?str2)
->
	(?t xpl:string ?str2)
]

# URI term = "patient"
[D10:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceSubject ?t) isUri(?t) (?t rdf:type xpl:Subject)
->
	(?t xpl:string "You")
]

# - objects

# qualified literal objects
[D11:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceObject ?o)  isLiteral(?o)
	(?en xpl:sourcePredicate ?p) (?p xpl:unit ?u)
	strConcat(?o ?u ?str)
->
	(?en xpl:objectString ?str)
]

# non-qualified literal objects
[D12:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceObject ?o)  isLiteral(?o) notDType(?o xsd:boolean)
	(?en xpl:sourcePredicate ?p) noValue(?p xpl:unit ?u)
	strConcat(?o '' ?str)
->
	(?en xpl:objectString ?str)
]

# URI objects (assumed non-qualified)
[D13:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceObject ?o) isUri(?o) (?o xpl:string ?str)
->
	(?en xpl:objectString ?str)
]

# - clauses

# predicates without placeholders (non-bool values)
[D1:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:objectString ?os)
	(?en xpl:sourcePredicate ?p) (?p xpl:string ?ps) noMatch(?ps ".*%s.*")
	strConcat (?ps ' ' ?os ?descr) trim(?descr ?descr2)
->
	(?deriv xpl:description ?descr2)
]

# predicates with placeholders (non-bool values)
[D3:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:objectString ?os)
	# includes a placeholder
	(?en xpl:sourcePredicate ?p) (?p xpl:string ?ps) regex(?ps ".*%s.*")
	replaceAll("%s" ?os ?ps ?ps2)
->
	(?deriv xpl:description ?ps2)
]

# boolean values
[D5:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceObject "true"^^xsd:boolean)
	(?en xpl:sourcePredicate ?p) (?p xpl:string ?ps)
->
	(?deriv xpl:description ?ps)
]

[D6:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceObject "false"^^xsd:boolean)
	(?en xpl:sourcePredicate ?p) (?p xpl:string ?ps)
	strConcat("no " ?ps ?descr)
->
	(?deriv xpl:description ?descr)
]

# functors
[D7:
	(<> xpl:output ?deriv) (?en xpl:derivation ?deriv)
	(?en xpl:sourceFunctorName ?n) (?bn xpl:builtinName ?n) (?bn rdfs:label ?l) 
	(?en xpl:sourceFunctorArgs ?a) listEntry(?a 1 ?val)
# get unit associated with any other antecedent
	(?deriv0 xpl:via ?en) getAny(?deriv0 xpl:via xpl:sourcePredicate xpl:unit ?unit) 
	strConcat(?l ' ' ?val ?unit ?description)
->
	(?deriv xpl:functorDescription ?description) 
	(?deriv xpl:description '')
]