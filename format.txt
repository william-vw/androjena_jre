> config per use case

- predicate of interest (e.g., hasDiagnosis, stratified)
there can be plenty of level-0 inferences that are not of interest
	i.e., not used to generate other derivations, but also not representing a conclusion 
		(e.g., an intermediate inference that ended up leading nowhere)



> multiple explanations for inferences of interest
e.g., for COPD: any of a series of inferences may lead to stratification

needed to adapt FRuleEngine to keep (different) derivations of already inferred triple
and, update rules as well :-/


> yes, a race condition
need ability to set saliency of rules 
(currently solved by applying "universal" rules in separate run)


> get highest-level explanations:

Yail templates + generators to fill in placeholders (?) + resources (?)
	using rules: not requiring a re-compilation (e.g., enter online location)
	custom Java file: likely more powerful & easier but requires re-compilation 
	or, using Yail ..

on-interaction 
	on-select derivation ..
		ideally just customize existing "scripts" (e.g., fill in custom images)
		or, those customizations could simply be linked to resources

want to avoid creating a new templating language here :-(


(?en0 a :NodeSet)

# en1 could e.g., unify with en0 if final notExists is true
<> log:notIncludes { ?en1!prov:wasGeneratedBy!prov:qualifiedUsage prov:entity ?en0 } .
(?en1 prov:wasGeneratedBy ?gen0) (?gen0 prov:qualifiedUsage ?us0) notExists(?us0 prov:entity ?en0)

# .. or generate a level integer
	(?en1 prov:wasGeneratedBy ?gen0) (?gen0 prov:derivationLevel 0)
->
	(?en1 epm:level 0)


# - generic preprocessing
# why not generate these in the printer .. much easier
# sort antecedents to get "deterministic" output ..



# domain-specific generators

-- selector 
	level of abstraction; contrastive 
	(can be combined)
	
-- generator
	 graphical; short sentences



>> selectors:


> contextual (dynamic, sensor-based values)

# https://www.w3.org/TR/prov-o/#hadPrimarySource
# https://www.w3.org/TR/prov-o/#qualifiedPrimarySource

	(<> tpl:output ?out) (?out tpl:type tpl:reason) 
	(?out tpl:entity ?en) (?out tpl:verb ?p) (?out tpl:object ?o)
	(?en prov:hadPrimarySource ?src) (?src a ssn:Sensor) # if also some sort of recency, then include it ..
->
	(?out tpl:included true)


	(<> tpl:output ?out) (?out tpl:type tpl:reason) (?out tpl:included true) 
	(?out tpl:entity ?en) (?out tpl:verb ?p) (?out tpl:object ?o)
	(?en prov:hadPrimarySource ?src) (?src a :HealthProfileOrSomething)
->
	remove(?out tpl:included true)
	(?out tpl:included false)
	
	
> contrastive
why this one, and not that one?
	requires a rule analysis

what would it take for me to be in yellow zone?
what would it take not to have to exercise / eat this pizza?
	run backward chainer (or some hacky method)
		goal = some recommendation
		and check which antecedents are missing	


> counter-factual (possibly combined w/ contrastive)
	simply requires re-running the rules with different inputs
	

> scientific
	should be rather straightforward


> trace-based
	should be rather straightforward


> case-based
	.. different type of reasoning (?)
	
---

"code"

ExplanationTemplate
	parametrizedTemplate
	
	instantiate()
		execute rules / query
		for each result / reason binding:
			create new component ..